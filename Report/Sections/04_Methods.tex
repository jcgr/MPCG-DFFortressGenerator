\section{Methods}
\label{04}

There are many ways ways to generate dungeons, some are discussed in \cite[Chapter 3]{PCGBook}. We did not feel that these methods were applicable to our project, as Dwarf Fortress is such a different game from most other dungeon-based games. Instead, we wrote our own map generation algorithm with a user interface to go with it.

For our map generation algorithm, we use two different algorithms: A map generation algorithm to generate the basic layout of the map (see section \ref{04_MapGeneration}) and evolutionary algorithms\cite[Chapter 2]{IoEC} to determine how the map layout can be used in the best way (see section \ref{04_Evolution}).

\subsection{Interface}
\label{04_Interface}

The interface was created for two purposes: To let the user select options for the map generation easily and to let the user browse the generated maps. 

We accomplished this by splitting the interface in two parts. The right part (see figure \ref{fig:ToolRight_02}) contains all the options for the map generation. The user can select the dimensions of the fortress he wants generated, the number of dwarves that should inhabit the fortress and which rooms that are required to have in the fortress.

The left part (see figure \ref{fig:ToolRight_02}) shows an empty box until maps have been generated, at which point it shows the map the user has selected. There are two dropdown menus which allows the user to select which of the generated maps they want to see and what layer of the map they are shown.

\insertPicture{0.5}{ToolLeft_02}{}

\insertPicture{0.3}{ToolRight_02}{}


% Map generation algorithm
\subsection{Map generation}
\label{04_MapGeneration}

For the map generation algorithm, we decided to write our own algorithm, as we could not find any other algorithm that could do specifically what we wanted. Our map generation algorithm works as follows:

\begin{enumerate}

	\item Create a map of the user-specified dimensions and calculate the number of rooms we want, based on how many dwarves the user expects to have in their fortress.

	\item Create an entrance to the fortress on the top layer along one side of the room.

	\item For each layer in the map (starting at the top one), make a list that contains all positions that are not dug out and then do the following:

	\begin{enumerate}
		
		\item Choose a random position from the list of open positions and use it as one corner of the room.

		\item Pick a random, diagonal direction (north/east, south/east, south/west or north/west), go 6 tiles that way and see if the positions in that direction are open.

		\item If they are open, build an empty room in the middle 4x4 square, set the tiles around that square to room walls, and remove the positions now occupied by the room from the list of open positions.

		\item Create a path from the room to the nearest entrance using Dijkstra (stairs on the lower levels count as entrances to that level).

		\item Once enough rooms have been created, or only 10\% of the layer is open, create stairs to the next layer, and connect these stairs to the entrance of the current layer.

		\item Repeat steps a) to e) for each layer until enough rooms have been built.

	\end{enumerate}

\end{enumerate}

\subsection{Evolution}
\label{04_Evolution}

While evolutionary algorithms often work in the same way, there are some points we feel are important to discuss in our implementation.

\subsubsection{Initialization of maps}
\label{04_Evolution_Initialization}

In order to evolve maps we need maps. At the beginning of the run, we generate 10 maps using the map generation algorithm described in section \ref{04_MapGeneration}. For every map we generate, we also find and save the distance from every room to every other room, as we need the distance for our objective function. Saving the distances ahead of time allows us to save time when we need the distances as we can simply look them up. 

We find the distances between rooms by using Dijkstra's algorithm\cite{Dijkstra}\cite{DijkstraOriginal}. Every room finds and saves the distance it has to every other room. In order to save time during this step, we save the direction in directions when a distance is found (the start room knows the distance to the target room and the target room knows the distance to the start room). Other ways of finding the distances are discussed in \ref{06_Distances}.

\subsubsection{Candidates for evolution}

The genotype (the thing that is evolved) for evolution is not the maps that are generated, but rather what is in each room in the map. We do not want to risk throwing a map out due its fitness being low, as it is possible that another genotype (which we will refer to as 'room assignment') for a map could be good.

This means that each map has its own set of room assignments that are not mixed between maps. For each generation in the evolution, a number of children are spawned from the currently best room assignment. For every new child, every room had a 30\% chance to be changed into a random room. After the mutation is finished, the best child will become the parent for the next generation assuming it is better than the parent it was spawned from.

This way of doing the evolution let us keep all the map layouts we generated at the beginning, while still being able to evolve them in order to reach better ways of building the fortress.

\subsubsection{Objective function}

Our objective function works in two steps. It first checks if the room assignment that is being evaluated has all the rooms the user requested. If not, it is penalized for every missing room.

After that, it calculates the the fitness value of each individual room. This calculation is based on the distance between the room and other rooms it has a relation to. Depending on whether it should be far from, or close to, the other rooms, its fitness is changed. 

When relations to other rooms have finished, the function also checks how many we have of that type of room already. If we have more than we expect we will need (varies from room type to room type), the room's fitness is lowered to a factor of $1 / 2^numberOfExcessRooms$. After this is done, the value of the room is added to the room assignment's total fitness value and the the process starts over with the next room.

\textbf{Need something about the relationships between rooms}

\subsubsection{Maps, room assignments and generations}

The evolution generated 10 different rooms. Each of these rooms generate 100 new room assignments every generation and there are 100 generations to evolve over. With these numbers, we are able to preset the user with enough maps for them to be able to find at least one that suits their purposes and each map has been evolved to the point where it should be useful.

\subsubsection{The algorithm as pseudocode}

\begin{enumerate}

	\item Create 10 different maps layout (using the map generation algorithm, see below) with empty rooms. When a map has been generated, find the distance from any room to all other rooms (see \ref{04_Evolution_Initialization}).

	\item For each map layout, create create a random initial room assignment.

	\item For every map layout, do the following every generation until enough generations have passed:

	\begin{enumerate}

		\item Use the current best room assignment as candidate for the generation.

		\item Create 100 mutations of the candidate.

		\item Calculate the fitness value for each room assignment.

		\item If a room assignment is better than its parent, replace the parent with the room assignment.

	\end{enumerate}

	\item At the end, for every map, copy its best room assignment into the actual map.

\end{enumerate}

\subsection{Taxonomy}
\label{04_Taxonomy}

Following the taxonomy in \cite{togelius2010search}, we have classified our algorithm as follows:

\begin{itemize}

	\item \textbf{Offline} - Our algorithm is run as part of a tool that does not integrate into Dwarf Fortress\footnote{ It is also quite slow which would make it poor for an online tool should it later be interfaced with the game\cite{togelius2011search}.}.

	\item \textbf{Optional Content} - It is up to the user whether they want to use the tool (and thereby the algorithm) or not.

	\item \textbf{Parameter Vectors} - The algorithm takes some parameters from the user (fortress dimensions, number of dwarves and which rooms the user wants).

	\item \textbf{Stochastic Generation} - Most of the generation uses randomness in order to determine what to do.

	\item \textbf{Generate-and-test} - We use evolutionary programming as part of the algorithm, which, by definition, tests everything it generates\footnote{It does, however, stop after a certain number of iterations and returns the best results.}.

\end{itemize}

%Evolution algorithm

% Objective function: Should factor in that there are some rooms that we do not want a lot of.

%How does your algorithm work? Describe in as much detail as you can fit into the report. Also, how did you interface it to the game?

%Algorithm: Generate various layouts by digging rooms in random (open) positions, then connecting them to the entrance. Evolve/mutate by swapping room content around for each layout and evaluating each room assignment for every layout.

%Discuss Dijkstra + AStar, fitness function, how distances are calculated (time saved later by spending time early)

%PCG Taxonomy: classify

%Multi-threading:

%Interface: We did not interface it directly into the game. We give the user a layout map that provides the best room layouts generated.

% Distance improvements:
% Find distance to rooms while generating path to entrances.
% For distance between multiple layers: Save distance to entrance/exit for every room and just add them together.
% Dijkstra: Use Dikjstra to find distance to ALL rooms instead of just looking for one specific room at a time.