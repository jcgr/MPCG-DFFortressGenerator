\section{Methods}
\label{04}

There are various different ways to generate dungeons, some are discussed in \cite[Chapter 3]{PCGBook}. Depending on the type of dungeon one wants

For our dungeon generation, we use two different algorithms: A map generation algorithm to generate the basic layout of the map (\ref{04_MapGeneration}) and evolutionary algorithms\cite[Chapter 2]{IoEC} to determine how the map layout can be used in the best way (\ref{04_Evolution}).

\subsection{Interface}
\label{04_Interface}

The interface for our tool is simple, as we want to avoid confusing the user. On the right is has the options for what the map should include and the dimensions of the map. On the left, the generated maps are shown.

\textbf{insert UI picture(s) here}

% Map generation algorithm
\subsection{Map generation}
\label{04_MapGeneration}

For the map generation algorithm, we decided to write our own algorithm, as we could not find any other algorithm that could do specifically what we wanted. Our map generation algorithm works as follows:

\begin{enumerate}

	\item Create a map of the user-specified dimensions and calculate the number of rooms we want, based on how many dwarves the user expects to have in their fortress.

	\item Create an entrance to the fortress on the top layer along one side of the room.

	\item For each layer in the map (starting at the top one), make a list that contains all positions that are not dug out and then do the following:

	\begin{enumerate}
		
		\item Choose a random position from the list of open positions and use it as one corner of the room.

		\item Pick a random, diagonal direction (north/east, south/east, south/west or north/west), go 6 tiles that way and see if the positions in that direction are open.

		\item If they are open, build an empty room in the middle 4x4 square, set the tiles around that square to room walls, and remove the positions now occupied by the room from the list of open positions.

		\item Create a path from the room to the nearest entrance using Dijkstra (stairs on the lower levels count as entrances to that level).

		\item Once enough rooms have been created, or only 10\% of the layer is open, create stairs to the next layer, and connect these stairs to the entrance of the current layer.

		\item Repeat steps a) to e) for each layer until enough rooms have been built.

	\end{enumerate}

\end{enumerate}

\subsection{Evolution}
\label{04_Evolution}

While evolutionary algorithms often work in the same way, there are some points we feel are important to discuss in our implementation.

\subsubsection{Initialization of maps}
\label{04_Evolution_Initialization}

In order to evolve maps we first need the maps. At the beginning of the run, we generate 10 maps using the map generation algorithm described in section \ref{04_MapGeneration}. For every map we generate, we also find, and save, the distance from every room to every other room, as we need the distance for our objective function. Saving the distances ahead of time allows us to save time when we need the distances as we can simply look them up.

During our testing, calculating distances between rooms was the slowest part of the entire process by far. This is due to two things: We use Dijkstra's algorithm\cite{Dijkstra} instead of the A* algorithm\cite{AStar}, which in many cases is slower. The other thing is that for each room we want to find distances from, we look for another specific room. When that room is found, we save the distances (for both rooms, as the distance is the same the other way). When looking for such a specific target, A* would have been a better choice and is discussed in detail in section \ref{06_Distances}.

\subsubsection{Candidates for evolution}

We decided that our genotype (the thing that is evolved) should not the maps that are generated, but rather what is in each room in the map. We do not want to risk throwing a map out due its fitness being low, as it is possible that another genotype (which we will refer to as 'room assignment') for a map could be good.

This means that each map has its own set of room assignments that are not mixed between maps. For each generation in the evolution, a number of children are spawned from the currently best room assignment. For every new child, every room had a 30\% chance to be changed into a random room. After the mutation is finished, the best child will become the parent for the next generation assuming it is better than the parent it was spawned from.

This way of doing the evolution let us keep all the map layouts we generated at the beginning, while still being able to evolve them in order to reach better ways of building the fortress.

\subsubsection{Objective function}

When the user starts the generation, they can select which rooms they want in their fortress (see section \ref{04_Interface}). If a room assignment that does not contain the chosen type of room, or enough of certain rooms (there are some the user will need more than one of, for example bedrooms and dining rooms), the room assignment will be penalized based on how many that are missing.

After the penalizing of missing rooms, the objective function iterates over every room and checks its distance to rooms that it has a relation to (a barracks should be close to the entrance, for example). Depending on the distance, the room is either penalized or rewarded. This is where calculating the distanced ahead of time (see \ref{04_Evolution_Initialization}) saves a lot of time, as we have all the values already. All we need to do is figure out which rooms are related.

\textbf{Need something about the relationships between rooms}

\subsubsection{Maps, room assignments and generations}

We decided to generate 10 different maps for the evolution. We kept the number fairly low, as \textbf{needs ending}.

For each generation, we decided to create 100 room assignments for every map. This gave us a huge variety of room assignments, which made it likely that at least one was better than its parent.

On top of that, we decided to evolve our maps over 1000 generations, as that guaranteed that we got to explore a lot of different layouts. 

\subsubsection{The algorithm as pseudocode}

\begin{enumerate}

	\item Create 10 different maps layout (using the map generation algorithm, see below) with empty rooms. When a map has been generated, find the distance from any room to all other rooms (see \ref{04_Evolution_Initialization}).

	\item For each map layout, create create a random initial room assignment.

	\item For every map layout, do the following every generation until enough generations have passed:

	\begin{enumerate}

		\item Use the current best room assignment as candidate for the generation.

		\item Create 100 mutations of the candidate.

		\item Calculate the fitness value for each room assignment.

		\item If a room assignment is better than its parent, replace the parent with the room assignment.

	\end{enumerate}

	\item At the end, for every map, copy its best room assignment into the actual map.

\end{enumerate}

%Evolution algorithm

% Objective function: Should factor in that there are some rooms that we do not want a lot of.

%How does your algorithm work? Describe in as much detail as you can fit into the report. Also, how did you interface it to the game?

%Algorithm: Generate various layouts by digging rooms in random (open) positions, then connecting them to the entrance. Evolve/mutate by swapping room content around for each layout and evaluating each room assignment for every layout.

%Discuss Dijkstra + AStar, fitness function, how distances are calculated (time saved later by spending time early)

%PCG Taxonomy: classify

%Multi-threading:

%Interface: We did not interface it directly into the game. We give the user a layout map that provides the best room layouts generated.

% Distance improvements:
% Find distance to rooms while generating path to entrances.
% For distance between multiple layers: Save distance to entrance/exit for every room and just add them together.
% Dijkstra: Use Dikjstra to find distance to ALL rooms instead of just looking for one specific room at a time.