namespace PCG_DFFortressGenerator.Evolution
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Linq;

    using PCG_DFFortressGenerator.Classes;
    using PCG_DFFortressGenerator.Classes.Rooms;

    /// <summary>
    /// The evolver used in evolving maps.
    /// </summary>
    public class Evolver
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Evolver"/> class.
        /// </summary>
        public Evolver()
        {
            this.NumberOfAssignmentsToGenerate = 10;
            MissingRoomPenalty = 100;
            MissingRoomPenaltyScalingFactor = 10;
            this.MutationChance = 0.3;
            this.ChildrenToSpawn = 100;
            this.NumberOfGenerations = 1000;
        }

        /// <summary>
        /// Gets the weights between areas.
        /// </summary>
        public static Dictionary<string, Dictionary<string, double>> AreaWeights { get; private set; }

        /// <summary>
        /// Gets the random object.
        /// </summary>
        public static Random Random { get; private set; }

        #region Mutation Values

        /// <summary>
        /// Gets or sets the penalty to apply to a fitness of an assignment if it does not contain the required rooms.
        /// </summary>
        public static double MissingRoomPenalty { get; set; }

        /// <summary>
        /// Gets or sets the amount to increase the penalty per generation.
        /// </summary>
        public static double MissingRoomPenaltyScalingFactor { get; set; }

        /// <summary>
        /// Gets or sets the number of different assignments that are used in evolution.
        /// </summary>
        public int NumberOfAssignmentsToGenerate { get; set; }

        /// <summary>
        /// Gets or sets the chance that a room will mutate into a different room.
        /// </summary>
        public double MutationChance { get; set; }

        /// <summary>
        /// Gets or sets the number of children to generate per parent in a new generation.
        /// </summary>
        public int ChildrenToSpawn { get; set; }

        /// <summary>
        /// Gets the number of generations to run.
        /// </summary>
        public int NumberOfGenerations { get; private set; }

        #endregion

        /// <summary>
        /// Gets the current generation of the evolution.
        /// </summary>
        public int CurrentGeneration { get; private set; }

        /// <summary>
        /// Gets the generated assignments.
        /// </summary>
        public List<AreaAssignmentsGenotype> GeneratedAssignments { get; private set; }

        /// <summary>
        /// Gets the maps generated by the evolver.
        /// </summary>
        public List<Map> GeneratedMaps { get; private set; }

        /// <summary>
        /// Gets or sets the required rooms for the area assignments.
        /// </summary>
        public Dictionary<string, int> RequiredAreas { get; set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="Evolver"/> class.
        /// </summary>
        /// <param name="x"> The height of the map. </param>
        /// <param name="y"> The width of the map. </param>
        /// <param name="z"> The depth of the map. </param>
        /// <param name="chosenAreas"> The required rooms for this evolution. </param>
        /// <param name="numberOfDwarves"> The number Of dwarves to plan for. </param>
        public void EvolveMaps(int x, int y, int z, List<Area> chosenAreas, int numberOfDwarves)
        {
            Random = new Random();
            this.CurrentGeneration = 0;
            this.GeneratedMaps = new List<Map>();
            this.GeneratedAssignments = new List<AreaAssignmentsGenotype>();
            this.RequiredAreas = GetRequiredAreas(chosenAreas, numberOfDwarves);
            AreaWeights = GenerateAreaWeights();

            var updateString = "Generating initial maps.";

            var numberOfRoomsRequired = CalculateNumberOfRooms(chosenAreas, numberOfDwarves);
            var lg = new MapGenerator(x, y, z, numberOfRoomsRequired);

            MainWindow.UpdateProgressBlock(updateString);
            for (var i = 0; i < this.NumberOfAssignmentsToGenerate; i++)
            {
                this.GeneratedMaps.Add(lg.GenerateNewMap());
                this.GeneratedMaps[i].CalculateDistancesBetweenAreas();
                MainWindow.UpdateProgressBlock(updateString + "\n Map " + (i + 1) + "/" + this.NumberOfAssignmentsToGenerate + " generated.");
            }

            updateString += "\n Map " + this.NumberOfAssignmentsToGenerate + "/" + this.NumberOfAssignmentsToGenerate + " generated. \n\n";

            this.GeneratedAssignments.Clear();
            this.CurrentGeneration = 0;

            for (var i = 0; i < this.NumberOfAssignmentsToGenerate; i++)
            {
                var listOfAreas = new List<AreaGenotype>();
                foreach (var b in this.GeneratedMaps[i].GetAllAreas())
                {
                    var areaToAdd = (b.AreaName == "@") ? new AreaGenotype(b.Distances, "@") : new AreaGenotype(b.Distances, AreaAssignmentsGenotype.GetRandomRoom());
                    listOfAreas.Add(areaToAdd);
                }

                this.GeneratedAssignments.Add(new AreaAssignmentsGenotype(this.CurrentGeneration, listOfAreas));
            }

            // Mutate layouts
            updateString += "Evolving maps.";
            MainWindow.UpdateProgressBlock(updateString);
            while (this.CurrentGeneration < this.NumberOfGenerations)
            {
                for (var l = 0; l < this.GeneratedAssignments.Count; l++)
                {
                    var children = new List<AreaAssignmentsGenotype>();
                    var parent = this.GeneratedAssignments[l];

                    for (var i = 0; i < this.ChildrenToSpawn; i++)
                    {
                        children.Add(parent.Mutate(this.CurrentGeneration, this.MutationChance, this.RequiredAreas));
                    }

                    var bestChild = children.FirstOrDefault(c => Math.Abs(c.FitnessValue - children.Max(assignment => assignment.FitnessValue)) < 1E-17);
                    var bestFit = ((bestChild != null) && (parent.FitnessValue <= bestChild.FitnessValue)) ? bestChild : parent;

                    this.GeneratedAssignments[l] = bestFit;
                }

                this.CurrentGeneration++;
                
                if (this.CurrentGeneration % 10 == 0)
                    MainWindow.UpdateProgressBlock(updateString + "\n Generation " + this.CurrentGeneration + "/" + this.NumberOfGenerations);
            }

            for (var i = 0; i < this.GeneratedMaps.Count; i++)
            {
                for (var j = 0; j < this.GeneratedAssignments[i].Areas.Count; j++)
                {
                    var oldArea = this.GeneratedMaps[i].GetAllAreas()[j];
                    var newName = this.GeneratedAssignments[i].Areas[j].Name;
                    var mapLayer = this.GeneratedMaps[i].MapLayers[oldArea.AreaTiles[0].Position.Z];
                    mapLayer.ReplaceArea(oldArea, oldArea.CopyWithNewAreaName(newName));
                }
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Evolver"/> class.
        /// </summary>
        /// <param name="x"> The height of the map. </param>
        /// <param name="y"> The width of the map. </param>
        /// <param name="z"> The depth of the map. </param>
        /// <param name="chosenAreas"> The required rooms for this evolution. </param>
        /// <param name="numberOfDwarves"> The number Of dwarves to plan for. </param>
        public void GenerateEvolutionTestData(int x, int y, int z, List<Area> chosenAreas, int numberOfDwarves)
        {
            Random = new Random();
            this.CurrentGeneration = 0;
            this.GeneratedMaps = new List<Map>();
            this.GeneratedAssignments = new List<AreaAssignmentsGenotype>();
            this.RequiredAreas = GetRequiredAreas(chosenAreas, numberOfDwarves);
            AreaWeights = GenerateAreaWeights();

            var numberOfRoomsRequired = CalculateNumberOfRooms(chosenAreas, numberOfDwarves);
            var lg = new MapGenerator(x, y, z, numberOfRoomsRequired);

            var sw = new Stopwatch();
            sw.Start();

            Console.WriteLine(@"Starting layout generation - " + (sw.ElapsedMilliseconds / 1000d));

            // Generate layouts and calculate distances between rooms for each layout.
            for (var i = 0; i < this.NumberOfAssignmentsToGenerate; i++)
            {
                Console.WriteLine(@"Layout " + i + @" started - " + (sw.ElapsedMilliseconds / 1000d));
                this.GeneratedMaps.Add(lg.GenerateNewMap());
                Console.WriteLine(@"Layout " + i + @" generated - " + (sw.ElapsedMilliseconds / 1000d));
                this.GeneratedMaps[i].CalculateDistancesBetweenAreas();
                Console.WriteLine(@"Distance for layout " + i + @" calculated - " + (sw.ElapsedMilliseconds / 1000d));
                Console.WriteLine(@"-----------------------------------");
            }

            // -----------------
            // Create all test setups
            // -----------------
            var testSetups = new List<TestSetups>();
            var testMutations = new[] { 0.1, 0.2, 0.3 };
            var testChildren = new[] { 10, 100, 1000 };
            var testPenalty = new[] { 10, 100, 200 };
            var testPenaltyModifier = new[] { 10, 100, 200 };
            for (var mut = 0; mut < testMutations.Count(); mut++)
            {
                for (var children = 0; children < testChildren.Count(); children++)
                {
                    for (var penalty = 0; penalty < testPenalty.Count(); penalty++)
                    {
                        for (var penaltyModifier = 0; penaltyModifier < testPenaltyModifier.Count(); penaltyModifier++)
                        {
                            testSetups.Add(new TestSetups(testMutations[mut], testChildren[children], (int)(10000d / testChildren[children]), testPenalty[penalty], testPenaltyModifier[penaltyModifier]));
                        }
                    }
                }
            }

            // -----------------
            // Test each setup
            // -----------------
            foreach (var testSetup in testSetups)
            {
                this.GeneratedAssignments.Clear();
                this.MutationChance = testSetup.TestMutationChance;
                this.ChildrenToSpawn = testSetup.TestChildrenToSpawn;
                this.NumberOfGenerations = testSetup.TestNumberOfGenerations;
                MissingRoomPenalty = testSetup.TestMissingRoomPenalty;
                MissingRoomPenaltyScalingFactor = testSetup.TestMissingRoomPenaltyScalingFactor;
                this.CurrentGeneration = 0;

                // Console.WriteLine("Initializeing layout populations - " + (sw.ElapsedMilliseconds / 1000d));
                for (var i = 0; i < this.NumberOfAssignmentsToGenerate; i++)
                {
                    var listOfAreas = new List<AreaGenotype>();
                    foreach (var b in this.GeneratedMaps[i].GetAllAreas())
                    {
                        var areaToAdd = (b.AreaName == "@") ? new AreaGenotype(b.Distances, "@") : new AreaGenotype(b.Distances, AreaAssignmentsGenotype.GetRandomRoom());
                        listOfAreas.Add(areaToAdd);
                    }

                    this.GeneratedAssignments.Add(new AreaAssignmentsGenotype(this.CurrentGeneration, listOfAreas));
                }

                Console.WriteLine();
                Console.WriteLine(@"-----------------------------------");
                Console.WriteLine();
                this.CurrentGeneration++;

                Console.WriteLine(@"Starting mutation - " + (sw.ElapsedMilliseconds / 1000d));

                // Mutate layouts
                while (this.CurrentGeneration < this.NumberOfGenerations)
                {
                    for (var l = 0; l < this.GeneratedAssignments.Count; l++)
                    {
                        var children = new List<AreaAssignmentsGenotype>();
                        var parent = this.GeneratedAssignments[l];

                        for (var i = 0; i < this.ChildrenToSpawn; i++)
                        {
                            children.Add(parent.Mutate(this.CurrentGeneration, this.MutationChance, this.RequiredAreas));
                        }

                        var bestChild = children.FirstOrDefault(c => Math.Abs(c.FitnessValue - children.Max(assignment => assignment.FitnessValue)) < 1E-17);
                        var bestFit = ((bestChild != null) && (parent.FitnessValue <= bestChild.FitnessValue)) ? bestChild : parent;

                        this.GeneratedAssignments[l] = bestFit;
                    }

                    Console.WriteLine(@"Generation " + this.CurrentGeneration + @"/" + this.NumberOfGenerations + @" is finished - " + (sw.ElapsedMilliseconds / 1000d));
                    this.CurrentGeneration++;
                }

                Console.WriteLine(@"Mutation finished - " + (sw.ElapsedMilliseconds / 1000d));
                Console.WriteLine();
                Console.WriteLine(@"-----------------------------------");
                Console.WriteLine();

                for (var i = 0; i < this.GeneratedMaps.Count; i++)
                {
                    for (var j = 0; j < this.GeneratedAssignments[i].Areas.Count; j++)
                    {
                        var oldArea = this.GeneratedMaps[i].GetAllAreas()[j];
                        var newName = this.GeneratedAssignments[i].Areas[j].Name;
                        var mapLayer = this.GeneratedMaps[i].MapLayers[oldArea.AreaTiles[0].Position.Z];
                        mapLayer.ReplaceArea(oldArea, oldArea.CopyWithNewAreaName(newName));
                    }
                }

                // -----------------
                // Print to file
                // -----------------
                var newDirectory = Directory.GetCurrentDirectory() + "\\TestData";
                var testDataDirectory = newDirectory + "\\Dwarf" + numberOfDwarves;
                var testDataFileName = testDataDirectory + "\\" + testSetup.AsFileName();
                if (!Directory.Exists(newDirectory))
                    Directory.CreateDirectory(newDirectory);
                if (!Directory.Exists(testDataDirectory))
                    Directory.CreateDirectory(testDataDirectory);

                using (var file = new StreamWriter(testDataFileName))
                {
                    // Find top 10 map indicies
                    file.WriteLine("Top 10 maps are:");
                    var topMaps = new List<int>();
                    for (int i = 0; i < 10; i++)
                    {
                        var topValue = -1000000d;
                        var topIndex = -1;

                        for (var mapIndex = 0; mapIndex < this.GeneratedMaps.Count; mapIndex++)
                        {
                            if (topMaps.Contains(mapIndex))
                                continue;

                            if (this.GeneratedAssignments[mapIndex].FitnessValue <= topValue)
                                continue;

                            topValue = this.GeneratedAssignments[mapIndex].FitnessValue;
                            topIndex = mapIndex;
                        }

                        topMaps.Add(topIndex);
                        file.WriteLine(i + ": Map " + topIndex + " with fitness: " + topValue);
                    }

                    file.WriteLine();
                    file.WriteLine("-----------------------------------");

                    // Print all maps with their layers
                    for (var mapIndex = 0; mapIndex < this.GeneratedMaps.Count; mapIndex++)
                    {
                        var map = this.GeneratedMaps[mapIndex];
                        file.WriteLine("Map " + mapIndex + " with fitness (" + this.GeneratedAssignments[mapIndex].FitnessValue + ") looks like this:");

                        for (var layer = map.Z - 1; layer >= 0; layer--)
                        {
                            if (map.MapLayers[layer].LayerAreas.Count <= 0)
                                continue;
                            file.WriteLine();
                            file.WriteLine("Layer " + layer);
                            file.WriteLine(map.MapLayers[layer].ToString());
                        }

                        file.WriteLine();
                        file.WriteLine("-----------------------------------");
                        file.WriteLine();
                    }
                }

                Console.WriteLine(@"Test data written to " + testDataFileName);
            }
        }

        /// <summary>
        /// The generate area weights.
        /// </summary>
        /// <returns> The Dictionary containing the weights between areas. </returns>
        private static Dictionary<string, Dictionary<string, double>> GenerateAreaWeights()
        {
            var finalDict = new Dictionary<string, Dictionary<string, double>>();
            const double Close = -1.0;
            const double Far = 1.0;

            // ----------
            // Rooms
            // ----------
            // Barracks
            var barrackDict = new Dictionary<string, double>
                                    {
                                        { "r", Close },
                                        { "@", Close }
                                    };
            finalDict.Add("r", barrackDict);

            // Bedroom
            var bedroomDict = new Dictionary<string, double> { { "@", Far } };
            finalDict.Add("b", bedroomDict);

            // Dining Room
            var diningroomDict = new Dictionary<string, double> { { "@", Far } };
            finalDict.Add("d", diningroomDict);

            // Entrance
            var entranceDict = new Dictionary<string, double>
                                    {
                                        { "@", Close },
                                        { "r", Close },
                                        { "b", Far },
                                        { "d", Far }
                                    };
            finalDict.Add("@", entranceDict);

            // Farm
            var farmDict = new Dictionary<string, double> { { "f", Close } };
            finalDict.Add("f", farmDict);

            // Office
            var officeDict = new Dictionary<string, double> { { "o", Close } };
            finalDict.Add("o", officeDict);

            // ----------
            // Workshops
            // ----------
            // Brewery
            var breweryDict = new Dictionary<string, double> { { "q", Close }, { "D", Close } };
            finalDict.Add("q", breweryDict);

            // Carpenter
            var carpenterDict = new Dictionary<string, double> { { "c", Close }, { "U", Close }, { "T", Close } };
            finalDict.Add("c", carpenterDict);

            // Craftdwarf
            var craftdwarfDict = new Dictionary<string, double>
                                    {
                                        { "¤", Close },
                                        { "G", Close },
                                        { "S", Close },
                                        { "T", Close }
                                    };
            finalDict.Add("¤", craftdwarfDict);

            // Fishery
            var fisheryDict = new Dictionary<string, double> { { "e", Close }, { "D", Close } };
            finalDict.Add("e", fisheryDict);

            // Kitchen
            var kitchenDict = new Dictionary<string, double> { { "k", Close }, { "D", Close } };
            finalDict.Add("k", kitchenDict);

            // Mason
            var masonDict = new Dictionary<string, double> { { "m", Close }, { "U", Close }, { "S", Close } };
            finalDict.Add("m", masonDict);

            // Metalsmith
            var metalsmithDict = new Dictionary<string, double> { { "h", Close }, { "B", Close }, { "W", Close } };
            finalDict.Add("h", metalsmithDict);

            // Smelter
            var smelterDict = new Dictionary<string, double> { { "s", Close }, { "u", Close }, { "B", Close } };
            finalDict.Add("s", smelterDict);

            // Wood Furnace
            var woodfurnaceDict = new Dictionary<string, double>
                                    {
                                        { "u", Close },
                                        { "s", Close },
                                        { "B", Close },
                                        { "T", Close }
                                    };
            finalDict.Add("u", woodfurnaceDict);

            // ----------
            // Stockpiles
            // ----------
            // BarBlock
            var barblockDict = new Dictionary<string, double>
                                    {
                                        { "B", Close },
                                        { "s", Close },
                                        { "h", Close },
                                        { "u", Close }
                                    };
            finalDict.Add("B", barblockDict);

            // Cloth
            var clothDict = new Dictionary<string, double> { { "C", Close } };
            finalDict.Add("C", clothDict);

            // Finished Goods
            var finishedgoodsDict = new Dictionary<string, double> { { "G", Close }, { "¤", Close } };
            finalDict.Add("G", finishedgoodsDict);

            // Food
            var foodDict = new Dictionary<string, double>
                                    {
                                        { "D", Close },
                                        { "d", Close },
                                        { "e", Close },
                                        { "k", Close },
                                        { "q", Close }
                                    };
            finalDict.Add("D", foodDict);

            // Furniture
            var furnitureDict = new Dictionary<string, double> { { "U", Close }, { "c", Close }, { "m", Close } };
            finalDict.Add("U", furnitureDict);

            // Leather
            var leatherDict = new Dictionary<string, double> { { "L", Close } };
            finalDict.Add("L", leatherDict);

            // Stone
            var stoneDict = new Dictionary<string, double> { { "S", Close }, { "¤", Close }, { "m", Close } };
            finalDict.Add("S", stoneDict);

            // Weaponry
            var weaponryDict = new Dictionary<string, double> { { "W", Close }, { "h", Close } };
            finalDict.Add("W", weaponryDict);

            // Wood
            var woodDict = new Dictionary<string, double>
                                    {
                                        { "T", Close },
                                        { "c", Close },
                                        { "¤", Close },
                                        { "u", Close }
                                    };
            finalDict.Add("T", woodDict);

            return finalDict;
        }

        /// <summary>
        /// Converts chosen areas and number of dwarves into a dictionary.
        /// </summary>
        /// <param name="chosenAreas">The areas chosen by the user.</param>
        /// <param name="numberOfDwarves">The number of dwarves to accommodate.</param>
        /// <returns>The dictionary.</returns>
        private static Dictionary<string, int> GetRequiredAreas(IEnumerable<Area> chosenAreas, int numberOfDwarves)
        {
            var ra = new Dictionary<string, int>();

            foreach (var tempName in chosenAreas.Select(t => t.AreaName))
            {
                if (tempName.Equals("b"))
                    ra.Add(tempName, (int)Math.Ceiling(numberOfDwarves / 8d));
                else if (tempName.Equals("d"))
                    ra.Add(tempName, (int)Math.Ceiling(numberOfDwarves / 6d));
                else if (tempName.Equals("r"))
                    ra.Add(tempName, (int)Math.Ceiling((int)Math.Ceiling(numberOfDwarves * 0.20) / 5d));
                else
                    ra.Add(tempName, 1);
            }

            return ra;
        }

        /// <summary>
        /// Calculates the number of rooms required.
        /// </summary>
        /// <param name="requiredAreas"> The areas that must be in the map. </param>
        /// <param name="numberOfDwarves"> The number of dwarves to take into account when generating. </param>
        /// <returns> The number of rooms required. </returns>
        private static int CalculateNumberOfRooms(List<Area> requiredAreas, int numberOfDwarves)
        {
            var rooms = 0;

            if (requiredAreas.OfType<Bedroom>().Any())
                rooms += (int)Math.Ceiling(numberOfDwarves / 8d);

            if (requiredAreas.OfType<DiningRoom>().Any())
                rooms += (int)Math.Ceiling(numberOfDwarves / 6d);

            if (requiredAreas.OfType<Barracks>().Any()) 
                rooms += (int)Math.Ceiling((int)Math.Ceiling(numberOfDwarves * 0.20) / 5d);

            rooms += numberOfDwarves / 2;
            return rooms;
        }

        /// <summary>
        /// Test setup used for generating maps with different constants.
        /// </summary>
        private class TestSetups
        {
            /// <summary>
            /// Initializes a new instance of the <see cref="TestSetups"/> class.
            /// </summary>
            /// <param name="mutationChance"> The mutation chance. </param>
            /// <param name="children"> The amount of children. </param>
            /// <param name="generations"> The number of generations. </param>
            /// <param name="missingPenalty"> The missing room penalty. </param>
            /// <param name="missingPenaltyScaling"> The missing penalty scaling. </param>
            public TestSetups(
                double mutationChance,
                int children,
                int generations,
                double missingPenalty,
                double missingPenaltyScaling)
            {
                this.TestMutationChance = mutationChance;
                this.TestChildrenToSpawn = children;
                this.TestNumberOfGenerations = generations;
                this.TestMissingRoomPenalty = missingPenalty;
                this.TestMissingRoomPenaltyScalingFactor = missingPenaltyScaling;
            }

            /// <summary>
            /// Gets the chance that a room will mutate into a different room.
            /// </summary>
            public double TestMutationChance { get; private set; }

            /// <summary>
            /// Gets the number of children to generate per parent in a new generation.
            /// </summary>
            public int TestChildrenToSpawn { get; private set; }

            /// <summary>
            /// Gets the number of generations to run.
            /// </summary>
            public int TestNumberOfGenerations { get; private set; }

            /// <summary>
            /// Gets the penalty to apply to a fitness of an assignment if it does not contain the required rooms.
            /// </summary>
            public double TestMissingRoomPenalty { get; private set; }

            /// <summary>
            /// Gets the amount to increase the penalty per generation.
            /// </summary>
            public double TestMissingRoomPenaltyScalingFactor { get; private set; }

            /// <summary>
            /// Gets the setup as a name for a file.
            /// </summary>
            /// <returns> The name as a <see cref="string"/>. </returns>
            public string AsFileName()
            {
                return "Mutation" + this.TestMutationChance
                    + "-Children" + this.TestChildrenToSpawn
                    + "-Generations" + this.TestNumberOfGenerations
                    + "-MissingPenalty" + this.TestMissingRoomPenalty
                    + "-MissingPenaltyFactor" + this.TestMissingRoomPenaltyScalingFactor 
                    + ".txt";
            }
        }
    }
}
